require 'io'
require 'os'

require 'src.rpc'
require 'src.response'

## if DEBUG then
	do
	  local log_file = io.open("lsp.log", "w")
	  local date = os.date("%Y/%m/%d", os.time())
	  local time = os.date("%X", os.time())
	  local logged_file = #[debug.getinfo(1).source]#
	  local line = #[debug.getinfo(1).currentline]#
	  assert(log_file):write(("[lua_lsp] " .. date .. " " .. time .. "  " .. logged_file .. ":" .. line .. ":" .. " Started\n"))
	  assert(log_file):close()
	end

	local function log(msg: auto) 
	  local log_file = io.open("lsp.log", "a")
	  local date = os.date("%Y/%m/%d", os.time())
	  local time = os.date("%X", os.time())
	  local logged_file = #[debug.getinfo(1).source]#
	  local line = #[debug.getinfo(1).currentline]#
	  assert(log_file):write(("[lua_lsp] " .. date .. " " .. time .. "  " .. logged_file .. ":" .. line .. ": " .. msg .. "\n"))
	  assert(log_file):close()
	end
## else
	local function log(msg: auto) end
## end

local stdin: string
local documents: hashmap(string, string)
local current_file: string
local current_uri: string

local root_uri_prog = io.popen("git rev-parse --show-toplevel")
local root_uri: string = root_uri_prog:read()


while true do
	stdin = stdin .. io.read(1)
	
	local request, content_len, err = rpc.decode(stdin)
	if err == "" then
		local request_method_obj = cJSON_GetObjectItem(request, "method") 
		local request_method = request_method_obj.valuestring
		local request_id_obj = cJSON_GetObjectItem(request, "id") 
		local request_id: integer
		if cJSON_IsNumber(request_id_obj) == 1 then
			request_id = request_id_obj.valueint
		end
		local request_params = cJSON_GetObjectItem(request, "params") 
		local request_text_document = cJSON_GetObjectItem(request_params , "textDocument") 
		local text_document_uri = cJSON_GetObjectItem(request_text_document, "uri") 
		if cJSON_IsString(text_document_uri) == 1 then
			current_uri = text_document_uri.valuestring
		end

		log("Method: " .. request_method)

		if request_method == "initialize" then
			io.write(response.initialize(request_id))
			io.flush()
		end

		if request_method == "textDocument/didOpen" then
			local current_file_path = current_uri:sub(#("file://") + #root_uri + 2)
			current_file = io.open(current_file_path):read("a")
			documents[current_uri] = current_file
		end

		if request_method == "textDocument/didClose" then
			documents:remove(current_uri)
		end

		if request_method == "textDocument/didChange" then
			if documents[current_uri] ~= nil then
				local content_changes = cJSON_GetObjectItem(request_params, "contentChanges")
				if cJSON_IsArray(content_changes) == 1 then
					local changes_size = cJSON_GetArraySize(content_changes)
					for change_index = 0, changes_size - 1 do
						local change_obj = cJSON_GetArrayItem(content_changes, change_index)
						local change_text_obj = cJSON_GetObjectItem(change_obj, "text")
						if cJSON_IsString(change_text_obj) == 1 then
							local change_text = change_text_obj.valuestring
							current_file = change_text
							documents[current_uri] = current_file
						end					
					end 
				end
			end
		end

		if request_method == "textDocument/hover" then
			local response = response.hover(request_id)
			io.write(response)
			io.flush()
		end

		if request_method == "textDocument/definition" then
			local request_position = cJSON_GetObjectItem(request_params , "position") 
			local current_line_obj = cJSON_GetObjectItem(request_position, "line") 
			local current_line: integer
			if cJSON_IsNumber(current_line_obj) == 1 then
				current_line = current_line_obj.valueint
			end
			local current_char_obj = cJSON_GetObjectItem(request_position, "character") 
			local current_char: integer
			if cJSON_IsNumber(current_char_obj) == 1 then
				current_char = current_char_obj.valueint
			end
			if documents[current_uri] ~= nil then
				current_file = documents[current_uri]
			end

			local go_to_definition: string
			local go_to_files: sequence(string)
			local go_to_s_lines: sequence(integer)
			local go_to_s_chars: sequence(integer)
			local go_to_e_lines: sequence(integer)
			local go_to_e_chars: sequence(integer)
			local file_scheme: string = "file://" 
			local line_num: integer

			for line in current_file:gmatch("([^\n]-)\n") do
				if line_num == current_line then

					local start_idx, end_idx = current_char, current_char

					while start_idx > 1 and not line:sub(start_idx - 1, start_idx - 1):match("[,]") do
					    start_idx = start_idx - 1
					end

					while end_idx < #line and not line:sub(end_idx + 1, end_idx + 1):match("[,]") do
					    end_idx = end_idx + 1
					end

					local phrase = line:sub(start_idx, end_idx)

					for part in phrase:gmatch("[^,]+") do
					    if line:match("require") then

							local path_matched, path_seq = part:match("require%s*[%(]?%s*['\"]([%w%.]+)['\"]%s*[%)]?")
							local path_start = line:find(path_seq[1], start_idx, true)
					        local path_end = path_start + #path_seq[1] - 1  

							if current_char >= path_start and current_char <= path_end then

								local root_matched = path_seq[1]:match("%w+%.*%w*")
								if root_matched then
									local path = path_seq[1]:gsub("%.","/") .. ".nelua"
									local git_paths = io.popen("git ls-files")
									for git_path in git_paths:lines() do
										if git_path == path then
											local go_to_file = file_scheme .. root_uri .. "/" .. path
											go_to_files:push(go_to_file)
											go_to_s_lines:push(0)
											go_to_s_chars:push(0)
											go_to_e_lines:push(0)
											go_to_e_chars:push(0)
										end
									end
									git_paths:close()
									break
								end

								local same_matched = path_seq[1]:match("%.%w+%.*%w*")
								if same_matched then
									local sub_uri = current_uri:sub(#file_scheme + #root_uri + 1)
									local current_file_matched, current_file_seq = sub_uri:match("(.*)/%w+%.nelua")
									local path: string
									if current_file_matched then
										path = current_file_seq[1]:sub(2) .. path_seq[1]:gsub("%.","/") .. ".nelua"
									end
									local git_paths = io.popen("git ls-files")
									for git_path in git_paths:lines() do
										if git_path == path then
											local go_to_file = file_scheme .. root_uri .. "/" .. path
											go_to_files:push(go_to_file)
											go_to_s_lines:push(0)
											go_to_s_chars:push(0)
											go_to_e_lines:push(0)
											go_to_e_chars:push(0)
											break
										end
									end
									git_paths:close()
									break
								end
					        end
					    end

						local function_matched, function_seq = line:match("([%w_]+[:.]?[%w_]+)%s*%((.*)%)?")
						if function_matched then
							local function_word = function_seq[1] 
							if function_word:match("[%w_]+[^:.]") then
								local git_finds = io.popen("git grep -n --column " .. function_word .. "\\(" .. " $(git rev-parse --show-toplevel)")
								for find in git_finds:lines() do
									if find:match("function") then
										local find_info_matched, find_info_seq = find:match("([^:]+):(%d+):(%d+):")
										if find_info_matched then
											local path = find_info_seq[1]
											local line = tointeger(find_info_seq[2]) - 1
											local char = tointeger(find_info_seq[3]) - 1
											local go_to_file = file_scheme .. root_uri .. "/" .. path
											go_to_files:push(go_to_file)
											go_to_s_lines:push(line)
											go_to_s_chars:push(char)
											go_to_e_lines:push(line)
											go_to_e_chars:push(char + #function_word)
										end
									end
								end
								git_finds:close()
								break
							end
						end
					end
				end
				line_num = line_num + 1
			end

			-- Should probably improve this
			go_to_definition = response.definition(go_to_files, go_to_s_lines, go_to_s_chars, go_to_e_lines, go_to_e_chars, request_id) 
			
			io.write(go_to_definition)
			io.flush()
		end

		if request_method == "textDocument/completion" then
			local response = response.completion(request_id) 
			io.write(response)
			io.flush()
		end
	
		if request_method == "shutdown" then
			os.exit()
		end

		stdin = ""
	end
end
