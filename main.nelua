require 'io'
require 'os'

require 'src.rpc'
require 'src.response'

## if DEBUG then
	do
	  local log_file = io.open("lsp.log", "w")
	  local date = os.date("%Y/%m/%d", os.time())
	  local time = os.date("%X", os.time())
	  local logged_file = #[debug.getinfo(1).source]#
	  local line = #[debug.getinfo(1).currentline]#
	  assert(log_file):write(("[lua_lsp] " .. date .. " " .. time .. "  " .. logged_file .. ":" .. line .. ":" .. " Started\n"))
	  assert(log_file):close()
	end

	local function log(msg: auto) 
	  local log_file = io.open("lsp.log", "a")
	  local date = os.date("%Y/%m/%d", os.time())
	  local time = os.date("%X", os.time())
	  local logged_file = #[debug.getinfo(1).source]#
	  local line = #[debug.getinfo(1).currentline]#
	  assert(log_file):write(("[lua_lsp] " .. date .. " " .. time .. "  " .. logged_file .. ":" .. line .. ": " .. msg .. "\n"))
	  assert(log_file):close()
	end
## else
	local function log(msg: auto) end
## end

local stdin: string
local documents: hashmap(string, string)
local current_file: string
local current_uri: string

local root_uri_prog = io.popen("git rev-parse --show-toplevel")
local root_uri: string = root_uri_prog:read()


while true do
	stdin = stdin .. io.read(1)
	
	local request, content_len, err = rpc.decode(stdin)
	if err == "" then
		local request_method_obj = cJSON_GetObjectItem(request, "method") 
		local request_method = request_method_obj.valuestring
		local request_id_obj = cJSON_GetObjectItem(request, "id") 
		local request_id: integer
		if cJSON_IsNumber(request_id_obj) == 1 then
			request_id = request_id_obj.valueint
		end
		local request_params = cJSON_GetObjectItem(request, "params") 
		local request_text_document = cJSON_GetObjectItem(request_params , "textDocument") 
		local text_document_uri = cJSON_GetObjectItem(request_text_document, "uri") 
		if cJSON_IsString(text_document_uri) == 1 then
			current_uri = text_document_uri.valuestring
		end

		log("Method: " .. request_method)

		if request_method == "initialize" then
			io.write(response.initialize(request_id))
			io.flush()
		end

		if request_method == "textDocument/didOpen" then
			local current_file_path = current_uri:sub(#("file://") + #root_uri + 2)
			current_file = io.open(current_file_path):read("a")
			documents[current_uri] = current_file
		end

		if request_method == "textDocument/didClose" then
			documents:remove(current_uri)
		end

		if request_method == "textDocument/didChange" then
			if documents[current_uri] ~= nil then
				local content_changes = cJSON_GetObjectItem(request_params, "contentChanges")
				if cJSON_IsArray(content_changes) == 1 then
					local changes_size = cJSON_GetArraySize(content_changes)
					for change_index = 0, changes_size - 1 do
						local change_obj = cJSON_GetArrayItem(content_changes, change_index)
						local change_text_obj = cJSON_GetObjectItem(change_obj, "text")
						if cJSON_IsString(change_text_obj) == 1 then
							local change_text = change_text_obj.valuestring
							current_file = change_text
							documents[current_uri] = current_file
						end					
					end 
				end
			end
		end

		if request_method == "textDocument/hover" then
			local response = response.hover(request_id)
			io.write(response)
			io.flush()
		end

		if request_method == "textDocument/definition" then
			local request_position = cJSON_GetObjectItem(request_params , "position") 
			local position_line = cJSON_GetObjectItem(request_position, "line") 
			local position_char = cJSON_GetObjectItem(request_position, "character") 
			local current_line: integer
			if cJSON_IsNumber(position_line) == 1 then
				current_line = position_line.valueint
			end
			local current_char: integer
			if cJSON_IsNumber(position_char) == 1 then
				current_char = position_char.valueint
			end
			if documents[current_uri] ~= nil then
				current_file = documents[current_uri]
			end

			local go_to_definition: string
			local go_to_file: string = "file://"
			local go_to_file_found: boolean
			local line_num: integer
			for line in current_file:gmatch("([^\n]-)\n") do
				if line_num == current_line then
					if line:match('require') then
						local root_require_matched, root_require_seq = line:match([[^(.*)require %(?['\"](%w+%.*%w*)['\"]%)?]])
						if root_require_matched then
							local len_w_require = #root_require_seq[1] + #("require")
							local require_path = root_require_seq[2]:gsub("%.","/") .. ".nelua"
							local git_paths = io.popen("git ls-files")
							for path in git_paths:lines() do
								if path == require_path and current_char > len_w_require then
									go_to_file = go_to_file .. root_uri .. "/" .. require_path
									log(go_to_file)
									go_to_definition = response.definition(go_to_file, request_id) 
									go_to_file_found = true
								end
							end
						end
						local same_require_matched, same_require_seq = line:match([[^(.*)require %(?['\"]%.(%w+%.*%w*)['\"]%)?]])
						if same_require_matched then
							local len_w_require = #same_require_seq[1] + #("require")
							local _, current_dir_seq = current_uri:match("^file://(.*)/[^/]+%.nelua$") 
							local uri_sub = current_dir_seq[1]:sub(#root_uri + 1):sub(2)
							local require_path = uri_sub .. "/" .. same_require_seq[2]:gsub("%.","/") .. ".nelua"
							log(require_path)
							local git_paths = io.popen("git ls-files")
							for path in git_paths:lines() do
								if path == require_path and current_char > len_w_require then
									go_to_file = go_to_file .. root_uri .. "/" .. require_path
									log(go_to_file)
									go_to_definition = response.definition(go_to_file, request_id) 
									go_to_file_found = true
								end
							end
						end
					end
				end
				line_num = line_num + 1
			end
			if not go_to_file_found then
				go_to_definition = response.definition(go_to_file, request_id) 
			end
			
			io.write(go_to_definition)
			io.flush()
		end

		if request_method == "textDocument/completion" then
			local response = response.completion(request_id) 
			io.write(response)
			io.flush()
		end
	
		if request_method == "shutdown" then
			os.exit()
		end

		stdin = ""
	end
end
