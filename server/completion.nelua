require 'io'

require 'utils.response'

local CompletionItemKind = @enum {
	Text = 1,
	Method,
	Function,
	Constructor,
	Field,
	Variable,
	Class,
	Interface,
	Module,
	Property,
	Unit,
	Value,
	Enum,
	Keyword,
	Snippet,
	Color,
	File,
	Reference,
	Folder,
	EnumMember,
	Constant,
	Struct,
	Event,
	Operator,
	TypeParameter,
}

local InsertTextFormat = @enum{
  PlainText = 1,
  Snippet
}

local Command = @record{
	title: string,
	command: string,
}

local function create_completion(doc: string, label: string, insert_t: string, insert_t_f: integer, comp_kind: integer): *cJSON
  local obj = cJSON_CreateObject()
  cJSON_AddItemToObject(obj, "documentation", cJSON_CreateString(doc))
  cJSON_AddItemToObject(obj, "label", cJSON_CreateString(label))
  cJSON_AddItemToObject(obj, "insertText", cJSON_CreateString(insert_t))
  cJSON_AddItemToObject(obj, "insertTextFormat", cJSON_CreateNumber(insert_t_f))
  cJSON_AddItemToObject(obj, "insertTextFormat", cJSON_CreateNumber(insert_t_f))
  cJSON_AddItemToObject(obj, "kind", cJSON_CreateNumber(comp_kind))
  return obj
end

local function completion(request_id: integer)
	local completions: sequence(*cJSON)
-------------- Keywords ---------------
  local keyword_global = create_completion("", "global", "global", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_global)

  local keyword_local = create_completion("", "local", "local", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_local)

  local keyword_nil = create_completion("", "nil", "nil", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_nil)

  local keyword_true = create_completion("", "true", "true", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_true)

  local keyword_false = create_completion("", "false", "false", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_false)

  local keyword_continue= create_completion("", "continue", "continue", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_continue)

  local keyword_fallthrough = create_completion("", "fallthrough", "fallthrough", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_fallthrough)

  local keyword_break = create_completion("", "break", "break", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_break)

  local keyword_goto = create_completion("", "goto", "goto", InsertTextFormat.PlainText, CompletionItemKind.Keyword)
	completions:push(keyword_goto)
---------------------------------------

----------- Primitive Types ----------- 
  local primitive_type_string= create_completion("", "string", "string", InsertTextFormat.PlainText, CompletionItemKind.Class)
	completions:push(primitive_type_string)

  local primitive_type_integer= create_completion("", "integer", "integer", InsertTextFormat.PlainText, CompletionItemKind.Class)
	completions:push(primitive_type_integer)

  local primitive_type_number= create_completion("", "number", "number", InsertTextFormat.PlainText, CompletionItemKind.Class)
	completions:push(primitive_type_number)
---------------------------------------

---------- Builtin functions ----------
  local builtin_func_require = create_completion([[
```
global function require(modname: string <comptime>)
```
Loads the given module `modname`.

The function starts by looking into loaded modules to determine whether `modname` is already loaded. If it is then require does nothing, otherwise it tries to load the module.

If there is any error loading the module, then the compilation fails. If there is any error running the module, then the application terminates.
]], "require(modname)", "require", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_require)

  local builtin_func_print = create_completion([[
```nelua
global function print(...: varargs): void
```

Receives any number of arguments and prints their values to the standard output, converting each argument to a string following the same rules of `tostring`. The values are separated by tabs and a new line is always appended.

The function `print` is not intended for formatted output, but only as a quick way to show a value, for instance for debugging. For complete control over the output, use `io.write` or `io.writef`.
panic
]], "print(...)", "print", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_print)

  local builtin_func_panic = create_completion([[
```nelua
global function panic(message: string): void
```

Terminate the application abnormally with message `message`. This function never returns.

Use to raise unrecoverable errors.
]], "panic(message)", "panic", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_panic)

  local builtin_func_error = create_completion([[
```nelua
global function error(message: string): void
```

Raises an error with message `message`. This function never returns.

Currently this is an alias to `panic` and terminates the application, but in the future, in case the language get an exception system, it may be changed to an exception being thrown.

Remarks: Error messages are dependent on the host environment the program is being compiled in, it may include terminal color codes and path to host machine files to make debugging error locations easier. You can disable this behavior by enabling the pragma `noerrorloc`, it will make the program error messages reproducible when building across different host machines.
]], "error(message)", "error", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_error)

  local builtin_func_assert = create_completion([[
```nelua
global function assert(v: auto, message: facultative(string))
```

Raises an error if the value `v` is evaluated to `false`, otherwise, returns `v`. In case of error, `message` is the error message, when absent defaults to `"assertion failed!"`.

Remarks: Error messages are dependent on the host environment the program is being compiled in, it may include terminal color codes and path to host machine files to make debugging error locations easier. You can disable this behavior by using the pragma `noerrorloc`, it will make the program error messages reproducible when building across different host machines.
]], "assert(v, message)", "assert", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_assert)

  local builtin_func_check = create_completion([[
```nelua
global function check(cond: boolean, message: facultative(string)): void
```

If `cond` is true it does nothing, otherwise raises an error with `message` and terminates the application. Similar to `assert` however itâ€™s completely omitted when compiling in release mode or with pragma `nochecks`. Use for assertive programming, to check if conditions are met without impacting performance of production code.

Remarks: Error messages are dependent on the host environment the program is being compiled in, it may include terminal color codes and path to host machine files to make debugging error locations easier. You can disable this behavior by using the pragma `noerrorloc`, it will make the program error messages reproducible when building across different host machines.
]], "check(cond, message)", "check", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_check)

  local builtin_func_likely = create_completion([[
```nelua
global function likely(cond: boolean): boolean
```

Returns `cond`. This is a branching prediction utility, expecting `cond` to evaluate to `true`.
]], "likely(cond)", "likely", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_likely)

  local builtin_func_unlikely = create_completion([[
```nelua
global function unlikely(cond: boolean): boolean
```

Returns `cond`. This is a branching prediction utility, expecting `cond` to evaluate to `false`.
]], "unlikely(cond)", "unlikely", InsertTextFormat.PlainText, CompletionItemKind.Function)
	completions:push(builtin_func_unlikely)
---------------------------------------

-------------- Snippets --------------
  local snippet_if = create_completion("", "if .. then", "if $1 then\n\nend", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_if)

  local snippet_elseif = create_completion("", "elseif .. then", "elseif $1 then", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_elseif)

  local snippet_while = create_completion("", "while .. do", "while $1 do\n\nend", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_while)

  local snippet_do = create_completion("", "do .. end", "do \n$1\n end", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_do)

  local snippet_switch = create_completion("", "switch .. end", "switch $1 do\n\nend", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_switch)

  local snippet_case = create_completion("", "case .. then", "case $1 then", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_case)

  local snippet_defer = create_completion("", "defer .. end", "defer \n$1\n end", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_defer)

  local snippet_repeat = create_completion("", "repeat .. until", "repeat\n\nuntil $1", InsertTextFormat.Snippet, CompletionItemKind.Snippet)
	completions:push(snippet_repeat)

  local snippet_forin_generic = create_completion(
		"", 
		"for .. pairs", 
		"for ${1:value} in ${2:func()} do\n\nend", 
		InsertTextFormat.Snippet, 
		CompletionItemKind.Snippet
	)
	completions:push(snippet_forin_generic)

  local snippet_forin_pairs = create_completion(
		"", 
		"for .. pairs", 
		"for ${1:key}, ${2:value} in pairs(${3:h}) do\n\nend", 
		InsertTextFormat.Snippet, 
		CompletionItemKind.Snippet
	)
	completions:push(snippet_forin_pairs)

  local snippet_forin_ipairs = create_completion(
		"", 
		"for .. ipairs", 
		"for ${1:index}, ${2:value} in ipairs(${3:a}) do\n\nend", 
		InsertTextFormat.Snippet, 
		CompletionItemKind.Snippet
	)
	completions:push(snippet_forin_ipairs)

  local snippet_forn = create_completion(
		"", 
		"for i = ..", 
		"for ${1:i} = ${2:1}, ${3:10} do\n\nend", 
		InsertTextFormat.Snippet, 
		CompletionItemKind.Snippet
	)
	completions:push(snippet_forn)

	local snippet_localfunc = create_completion(
		"", 
		"local function", 
		"local function $1()\n\nend", 
		InsertTextFormat.Snippet, 
		CompletionItemKind.Snippet
	)
	completions:push(snippet_localfunc)

	local snippet_globalfunc = create_completion(
		"", 
		"global function", 
		"global function $1()\n\nend", 
		InsertTextFormat.Snippet, 
		CompletionItemKind.Snippet
	)
	completions:push(snippet_globalfunc)

---------------------------------------

	local completion_response = response.completion(request_id, completions)
	io.write(completion_response)
	io.flush()
end

return completion
