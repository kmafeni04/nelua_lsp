require 'io'

require 'utils.logger'
require 'utils.response'

local function go_to_definition(
	root_uri: string,
	request_params: *cJSON,
	request_id: integer,
	documents: hashmap(string, string),
	current_uri: string,
	current_file: string,
	current_line: integer,
	current_char: integer,
	parse_err: boolean
)

	if documents:peek(current_uri) ~= nilptr then
		current_file = documents[current_uri]
	end

	-- if parse_err then
	-- 	goto definition_found
	-- end

	local go_to_definition: string
	local go_to_uris: sequence(string)
	local go_to_s_lines: sequence(integer)
	local go_to_s_chars: sequence(integer)
	local go_to_e_lines: sequence(integer)
	local go_to_e_chars: sequence(integer)
	local file_scheme: string = "file://" 

	local keywords: hashmap(string, boolean)
	keywords["local"] = true
	keywords["global"] = true
	keywords["function"] = true
	keywords["require"] = true
	keywords["nil"] = true
	keywords["true"] = true
	keywords["false"] = true
	keywords["for"] = true
	keywords["while"] = true
	keywords["do"] = true
	keywords["end"] = true
	keywords["in"] = true
	keywords["then"] = true
	keywords["not"] = true
	keywords["defer"] = true
	keywords["break"] = true
	keywords["fallthrough"] = true
	keywords["switch"] = true
	
	local line_num: integer
	for line in current_file:gmatch("([^\n]-)\n") do
		if line_num == current_line then
---------- Require statements -----------
			if line:match("%f[%w_]require%f[^%w_]") then
				for require_statement, path_seq in line:gmatch("require%s*%(?%[?['\"%[]([%w_%.]+)['\"%]]%]?%s*%)?") do 
					local path_search_start = line:find(require_statement, 1, true)
					local path_start = line:find(path_seq[0], path_search_start)
	        local path_end = path_start + #path_seq[0] - 1 
					if current_char >= path_start - 1 and current_char <= path_end - 1 then
						local git_paths <close> = io.popen("git ls-files && git ls-files --others")
						local path = line:sub(path_start, path_end):gsub("%.","/")
						local current_path = current_uri:sub(#file_scheme + #root_uri + #"/" + 1)
						local same_dir = path:match("^/.+$")
						if same_dir then
							local child, child_seq = current_path:match("/.+nelua")
							if child then
								local parent_dir = current_path:sub(1, #current_path - #child_seq[1])
								for file in git_paths:lines() do
									if file == parent_dir .. path .. ".nelua" then
										local go_to_uri = file_scheme  .. root_uri .. "/" .. parent_dir .. path .. ".nelua"
										go_to_uris:push(go_to_uri)
										go_to_s_lines:push(0)
										go_to_s_chars:push(0)
										go_to_e_lines:push(0)
										go_to_e_chars:push(0)
										goto definition_found
									end
								end
							end
						else
							for file in git_paths:lines() do
								if file == path .. ".nelua" then
									local go_to_uri = file_scheme  .. root_uri .. "/" .. path .. ".nelua"
									go_to_uris:push(go_to_uri)
									go_to_s_lines:push(0)
									go_to_s_chars:push(0)
									go_to_e_lines:push(0)
									go_to_e_chars:push(0)
									goto definition_found
								end
							end
						end
					end
				end
			end
-----------------------------------------
				
			local start_idx, end_idx = current_char, current_char

			while start_idx > 0 and line:sub(start_idx - 1, start_idx - 1):match("%f[%w_][%w_]+%f[^%w_]") do
				start_idx = start_idx - 1
			end
			while end_idx > 0 and line:sub(end_idx + 1, end_idx + 1):match("%f[%w_][%w_]+%f[^%w_]") do
				end_idx = end_idx + 1
			end

			local word = line:sub(start_idx, end_idx)

			for identifier in line:gmatch("%f[%w_]([%w_]+)%f[^%w_]") do
				if not keywords[identifier] and identifier == word then
------- Local and Global Variables ------
-----------------------------------------
				end
			end
		end

		line_num = line_num + 1
	end

	
	::definition_found::

	local definition_response = response.definition(request_id, go_to_uris, go_to_s_lines, go_to_s_chars, go_to_e_lines, go_to_e_chars)
	io.write(definition_response)
	io.flush()
end

return go_to_definition
